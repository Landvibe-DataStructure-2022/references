# 분석 방법 및 배열과 연결 리스트 [자료구조]

## 목차

- 분석 방법
- 배열
- 연결 리스트

## 분석 방법

- 프로그램의 성능 분석은 `시간 복잡도`와 `공간 복잡도` 로 분석한다.
    - **시간 복잡도**
        
        <aside>
        💡 프로그램을 수행하는데(문제를 해결하는데) 얼마나 시간이 걸리는지
        
        </aside>
        
    - **공간 복잡도**
        
        <aside>
        💡 프로그램을 수행하는데(문제를 해결하는데) 얼마나 메모리를 쓰는지
        
        </aside>
        
    
- 분석 방법은 `점근 분석` 을 통해 분석한다.
    - 실행시간을 재는 게 아닌가요?
        - 실행 시간을 직접 측정하려면 측정할 수 있다.
        - 하지만, 실행 시간은 환경의 제약을 받는다 !!
        - 완전히 극단적인 예시) 동일한 프로그램을 최신형 맥북 프로에서 실행시켰을 때와, 20년 된 데스크탑에서 실행시켰을 때 실행 시간이 같을까? **아니다.**
        
        <aside>
        💡 실행 시간은 실행 환경에 의해 좌지우지되기 때문에, 실행 시간을 직접 측정하기보다는 점근적인 분석 방법을 사용한다.
        
        </aside>
        
    - 점근적인 분석 방법이 뭔데요?
        - 알고리즘의 복잡도를 대략적으로 분석하는 방법이다.
        - 직접 측정하는 실행 시간 대신, 연산의 실행 횟수를 카운트해서 분석한다.
        - 연산의 실행 횟수는 **입력 데이터**(input)**의 크기에 관한 함수**로 표현한다.
        - 크게 Big-O, Big-Omega, Big-Theta 등의 3가지로 분석한다.
        
    
    - **`Big-O(최악의 경우)`**
        - O(N^2) → 최악의 경우 input N에 대해 N^2번의 연산이 수행되는 경우
        - 아무리 느려도 N^2번의 연산 내로 해결할 수 있다.
    - `Big-Omega(최선의 경우)`
        - Ω(N^2) → 최선의 경우 input N에 대해 N^2번의 연산이 수행되는 경우
        - 아무리 빨라도 N^2번 그 이상의 연산으로 해결할 수 있다.
    - `Big-Theta(최선과 최악의 중간)`
        - Θ(N^2) → 항상 N^2번의 연산이 수행되는 경우
        - Big-O이면서 동시에 Big-Omega인 경우라고 할 수 있다.
        
    - Big-O가 가장 중요하다. 왜일까?
        
        O(N^2)라는 말의 의미가 뭐였는지 다시 생각해보자. 
        
        O(N^2)는 최악의 경우 N^2번의 연산이 수행된다는 뜻이다. 즉, 아무리 느려도 N^2번의 연산 안에 해결할 수 있다는 뜻이다.
        
        최악의 시간이 걸려도(최악의 상황이라 연산을 N^2번 했어도) 문제를 제한 시간 내에 해결했다면(성공했다면), **시간의 측면에서 모든 경우 성공한다고 생각할 수 있다.**
        
    
- 실제 분석 방법
    - 모든 연산의 실행 횟수를 재는 건 부질없다 ...
    - 따라서, 반복문을 통해 연산 횟수를 측정하는 방식으로 분석한다 !
    - O(N)인 반복문
        
        ```cpp
        // O(N)인 코드
        int n;
        cin >> n;
        
        int a = 0;
        
        for (int i = 0; i < n; i++) {
        	a++;
        }
        ```
        
    - O(N^2)인 반복문
        
        ```cpp
        // O(N^2)인 코드
        int n;
        cin >> n;
        
        int a = 0;
        
        for(int i = 0; i < n; i++) {
        	for(int j = 0; j < n; j++) {
        		a++;
        	}
        }
        ```
        
    - O(N^3)인 반복문
        
        ```cpp
        // O(N^3)인 코드
        int n;
        cin >> n;
        
        int a = 0;
        
        for(int i = 0; i < n; i++) {
        	for(int j = 0; j < n; j++) {
        		for(int k = 0; k < n; k++) {
        			a++;
        		}
        	}
        }
        ```
        
    - 실제로 분석 결과를 어떤 식으로 활용하나요 ?
        
        우리는 백준이나 프로그래머스에서 문제를 풀다보면 이런 것을 확인할 수 있습니다.
        
        <img width="285" alt="image" src="https://user-images.githubusercontent.com/81508084/157474141-24eb5817-8c00-4c7d-97f9-1caab58450ac.png">
        
        시간 제한 내에 문제를 풀 수 있도록 코드를 작성해야 한다는 뜻입니다.
        
        일반적으로 연산 2~3억 번을 1초 정도 걸린다고 생각합니다.
        
        만약 어떤 알고리즘이 O(N^2)라면, N≤10000인 경우 N^2이 1억이기 때문에 거의 1초 안에 수행되므로 시간 제한 내로 수행이 가능하다고 판단합니다. 10000≤N≤20000이라면 상황에 따라 다릅니다. N≥20000이라면, N^2이 4억이기 때문에 불가능하다고 판단할 수 있습니다.
        
    

## 배열(Array)

- 배열이란, 데이터들의 연속된 집합이다.
- (동적 할당할 수 있지만 보통) 정해진 크기만큼 선언한다.
- 각각의 element가 연속된 메모리 공간에 위치한다.

    ![Untitled](%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20%E1%84%87%E1%85%A1%E1%86%BC%20e47eb/Untitled%201.png)

- 장점
    - 구현이 간단하다.
    - index를 활용해 배열의 element에 바로 접근할 수 있다.
- 단점
    - 고정된 크기로 선언하기 때문에, 데이터 갯수가 배열의 크기보다 작을 경우에는 배열에 이미 공간을 할당해놓았으므로 메모리가 낭비된다. 반면 데이터 갯수가 배열의 크기보다 클 경우, 공간 부족으로 인해 더이상 데이터를 담지 못하는 불상사가 초래된다.
    - 데이터를 중간에 끼워넣거나(삽입), 중간에 있는 데이터를 빼면(삭제) 해당 위치 이후의 element들을 한 칸씩 뒤로 밀거나 앞으로 당겨야 한다. 진짜 최악의 경우, 0번째 index에서 삽입, 삭제가 이루어질 경우에는 배열 전체를 밀고 당겨야 하는 불상사가 발생한다 ...

## 연결 리스트(Linked List)

- 링크드 리스트란, 데이터들이 담긴 노드를 줄줄이 연결한 자료구조이다.
- 노드란, 쉽게 설명하면 하나의 요소 정도로 이해하면 된다.
- 배열과 달리 크기를 정해두지 않는다.

    ![image](https://user-images.githubusercontent.com/81508084/157474609-adc908df-0d2f-415d-96da-50263861c298.png)

    ![image](https://user-images.githubusercontent.com/81508084/157474853-6f189213-3e4e-49fb-8965-ded30abb7c81.png)

- 장점
    - 필요할 때마다 메모리를 동적으로 할당하기 때문에 메모리 측면에서 효율적이다.
    - 중간에 데이터를 삽입, 삭제할 때 배열처럼 다른 데이터들을 한 칸씩 이동시키지 않아도 되기 때문에 효율적이다.
        
        ex) D를 삭제할 경우, C→D를 끊고 C→E로 해주면 되기 때문에 효율적이다. ~~배열이었다면 E부터 G까지 다 한 칸씩 땡겨줘야겠지 ...~~
        
- 단점
    - (배열에 비해) 구현이 복잡하다.
    - 중간에 있는 데이터에 접근하려면 첫 노드(head)부터 하나씩 노드를 타고 이동하면서 찾아야 한다.

## 배열 vs 링크드 리스트

|  | 배열 | 링크드리스트 |
| --- | --- | --- |
| 접근 | O(1) | O(N) |
| 삽입 | O(N) | O(1) |
| 삭제 | O(N) | O(1) |
- **접근**
    
    ![image](https://user-images.githubusercontent.com/81508084/157475066-27ddffb9-f641-4a2f-a7c5-f89b2c5c4e0c.png)
    
    - 배열은 인덱스로 바로 접근이 가능하다. (O(1))
    - 링크드 리스트는 head에서부터 원하는 노드까지 하나하나 찾아가야 한다. (O(N))
- **삽입**
    
    <img width="1028" alt="image" src="https://user-images.githubusercontent.com/81508084/157475319-186247e8-f058-4ece-abd0-58195420d004.png"> 
    
    - 배열은 중간에 추가할 경우, 추가할 인덱스부터 배열의 맨 끝까지 한 칸씩 뒤로 밀어줘야 한다. (O(N))
    - 링크드 리스트는 중간에 추가할 경우, 추가할 위치의 앞 노드의 포인터(다음 노드의 주소를 가리키는 포인터)만 추가하는 노드로 변경해주고 추가하는 노드의 포인터(다음 노드의 주소를 가리키는 포인터)를 추가할 위치에 있던 노드로 변경해주면 된다. (O(1))
- **삭제**
    - 배열은 중간에 삭제할 경우, 삭제된 인덱스 다음부터 배열의 맨 끝까지 한 칸씩 앞으로 당겨줘야 한다. (O(N))
    - 링크드 리스트는 중간에 삭제할 경우, 삭제한 위치 앞뒤의 노드 간의 포인터만 수정하면 된다. (O(1))
    
- 하지만 위의 삽입, 삭제의 시간복잡도는 말 그대로 **삽입, 삭제 자체의 시간만 나타낸 것**이다. 삽입, 삭제를 하기 위해서 **링크드 리스트는 삽입, 삭제가 이루어질 위치까지 접근**해야 한다. 따라서, n번째 위치에 새로운 데이터를 삽입하거나 삭제하는데 드는 총 시간은 접근 O(N) + 삽입/삭제 (O(1)) → O(N)이 된다.